---
description: Code cleanup - removal of unused fields, debugs, logs and dead code
alwaysApply: true
globs: ["visary/**/*.py", "**/*.js"]
---

# Code Cleanup - Fields, Debugs, Logs and Dead Code

## Fundamental Principle

**ALWAYS identify and remove unused, legacy, unnecessary fields, debugs and logs**. Keep code clean, only with what is really necessary.

## Mandatory Rules

### 1. Unused Field Identification

During analysis/correction/review, **ALWAYS** verify:
- Fields in models not referenced in views, serializers, forms, templates, queries
- Legacy fields from old versions that no longer make sense
- Duplicated or redundant fields
- Fields defined but never populated or read
- Unused relationships (ForeignKey, ManyToMany)

### 2. Validation Before Removal

Before removing a field, validate:
1. Search references in code (grep/search):
   - Views, serializers, forms, templates
   - ORM queries, filters, ordering
   - JavaScript/frontend that accesses the field
   - Old migrations (may indicate historical use)
   - Documentation/comments
2. If no references found:
   - Field can be removed
   - Create migration to remove field from database
3. If references found but field not necessary:
   - Remove references first
   - Then remove field from model
   - Create migration to remove from database

### 3. Removal Implementation

When identifying unused or unnecessary field:
1. **Remove from model**: delete field from Model class
2. **Remove references**: delete all found references (views, serializers, forms, templates, JS)
3. **Create migration**: generate migration to remove field from database
4. **Validate**: confirm there are no other hidden references

### 4. New Implementations

When creating new models/fields:
- **Only extremely necessary fields**: don't create fields "just in case" or "may be useful in future"
- **Correct relationships**: only ForeignKey/ManyToMany when really necessary
- **Validate necessity**: each field must have clear and immediate use
- **Avoid redundant fields**: don't duplicate information already available in other fields/relationships

### 5. Field Checklist

Before adding a new field, ask:
1. Is this field really necessary now?
2. Is information not available via relationship?
3. Am I not duplicating existing information?
4. Will field be used immediately after creation?
5. Is relationship correct and necessary?

### 6. Analysis Process

During code analysis:
1. **Read complete model file** (from start to finish, without partial analysis)
2. **List all fields** of the model
3. **Search references** of each field in code (read complete files where field is referenced)
4. **Identify unused or unnecessary fields**
5. **Validate necessity** of each field
6. **Implement removal** if field not necessary

**IMPORTANT**: To correctly identify unused fields, it's necessary to read complete files where field may be referenced. Partial analyses can miss important references.

### 7. Exceptions

Fields that can be kept even without immediate use:
- **Audit fields**: created_at, updated_at, created_by (if project pattern)
- **Soft delete fields**: deleted_at, is_active (if project pattern)
- **Configuration fields**: settings, flags that are part of base architecture

But even these must be validated: if not used, consider removing.

## Debugs and Logs

### 1. Mandatory Rule: NEVER Implement Debugs

- **NEVER implement** `print()`, `console.log()`, `logger.debug()`, `logger.info()`, or any type of debug/log in code
- **NEVER add** breakpoints, temporary debugs, or debug tools
- Code must be clean and without debug instrumentation

### 2. Removal of Identified Debugs

During analysis/correction/review, **ALWAYS** identify and remove:
- `print()` statements
- `console.log()` in JavaScript
- `logger.debug()`, `logger.info()`, `logger.warning()` (except critical error logs manually inserted by operator)
- Breakpoints or debug code
- Commented code used for debug
- Temporary variables created only for debug

### 3. System Log Removal

- **ALWAYS remove logs** from system when identifying
- **Logs must be manually inserted by operator**, never automatically by code
- Remove:
  - `logger.debug()`, `logger.info()`, `logger.warning()`
  - Automatic request/response logs
  - Validation or processing logs
  - Any automatic logging in code

### 4. Exceptions (Critical Logs)

Only critical error logs manually inserted by operator can be kept:
- `logger.error()` or `logger.critical()` for critical system errors
- Only if manually inserted and really necessary for production diagnosis

### 5. Logs That Break Commands

**Critical Problem**: Automatic logs can break PowerShell commands, especially during module import.

**Symptoms**:
- Commands like `python visary/manage.py check` generate `RemoteException` or `NativeCommandError` errors
- Log outputs are interpreted as errors by PowerShell
- Commands fail even when execution was successful

**Root Cause**:
- Automatic logs (`logger.info`, `logger.debug`, `logger.warning`) executed during module import
- Logs in `__init__` of classes or at module level
- Logs that execute before main command logic

**Mandatory Solution**:
1. **ALWAYS remove automatic logs** that execute during import
2. **NEVER place logs in `__init__`** of classes or at module level
3. **Validate commands after removing logs**: execute `python visary/manage.py check` to confirm no more log outputs
4. **Search logs in initialization**: verify `__init__`, module level imports, and service initialization

**Identification**:
- Search: `logger.info(`, `logger.debug(`, `logger.warning(` in `__init__` or module level
- Verify if logs execute during import (not only during method calls)
- Test command after removing logs to validate correction

### 6. Cleanup Process

When identifying debugs or logs:
1. **Search in code**: `print(`, `console.log(`, `logger.`, `debug`, `DEBUG`
2. **Identify context**: verify if it's debug/log or necessary code
3. **Verify if executes during import**: logs in `__init__` or module level are critical
4. **Remove immediately**: delete all debug/log occurrences
5. **Validate command**: execute `python visary/manage.py check` to confirm no more outputs
6. **Confirm**: validate there are no other hidden occurrences

## Examples

### Bad (Unused Field)

```python
class User(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()
    old_phone = models.CharField(max_length=20)  # Not used, legacy
    unused_field = models.BooleanField(default=False)  # Never used
```

### Good (Only Necessary Fields)

```python
class User(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()
    # Legacy fields removed
```

### Bad (Redundant Field)

```python
class Order(models.Model):
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    customer_name = models.CharField(max_length=100)  # Redundant, already has customer.name
```

### Good (Uses Relationship)

```python
class Order(models.Model):
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    # customer.name already available via relationship
```
