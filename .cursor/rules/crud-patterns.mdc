---
description: CRUD patterns and dynamic architecture - generic, expandable and configurable code
alwaysApply: true
globs: ["visary/**/*.py"]
---

# CRUD Patterns and Dynamic Architecture

## Fundamental Principle

**ALWAYS think in CRUD**: Create, Read, Update, Delete. Every implementation must follow this generic and reusable pattern.

## Mandatory Rules

### 1. CRUD Mentality

- **Before implementing any functionality**, identify necessary CRUD operations
- Create generic views/services that work for any entity/model
- Avoid creating code specific to a single entity when it can be generic

### 2. Zero Hardcode

- **NEVER** use fixed values, hardcoded IDs, fixed field names, or specific structures
- **ALWAYS** make code:
  - **Dynamic**: use configuration, parameters, or database data
  - **Expandable**: easy to add new entities/fields without modifying existing code
  - **Configurable**: allow customization via settings, models or parameters

### 3. Simplicity and Directness

- **Avoid complex conditional structures**: nested if/elif/else, multiple switches
- Prefer:
  - Dictionaries/maps for mappings
  - Polymorphism/base classes for variations
  - Configuration instead of conditional logic
- **Keep code linear and easy to follow**: direct flow, without complex logical jumps

### 4. Implementation Patterns

#### Views/APIs

- Use generic views (Django Generic Views) or reusable base classes
- Parameters via URL/query string, not fixed values
- Generic serialization based on models, not fixed structures

#### Services

- Generic services that receive model/class as parameter
- Methods that work for any entity following the same pattern
- Avoid entity-specific methods (ex: `get_user_by_id`, `get_product_by_id` â†’ use `get_by_id(model, id)`)

#### Models

- Configurable fields via Meta or settings when possible
- Generic relationships when applicable
- Avoid hardcoded specific fields when it can be generic

### 5. Acceptable Exceptions

- **Initial seed/migration commands**: default data for system initialization
- **Environment configurations**: environment variables, settings.py (but still prefer dynamic when possible)
- **Specific business validations**: when really necessary for critical business rule

### 6. Checklist Before Implementing

Before writing code, ask:
1. Can this be generic/CRUD?
2. Is there any hardcoded value that can be dynamic?
3. Can I avoid complex if/elif/else?
4. Will code be easy to expand for new entities?
5. Am I following existing project patterns?

### 7. Existing Code Refactoring

- **Read complete file before refactoring** (from start to finish, without partial analysis)
- When finding hardcoded or specific code, consider refactoring to generic CRUD pattern
- Identify repeated patterns and extract to generic functions/classes
- Prioritize reuse over specific code

## Examples

### Bad (Hardcode, Specific)

```python
def get_user_report(user_id):
    if user_id == 1:
        return "Admin Report"
    elif user_id == 2:
        return "Manager Report"
    else:
        return "User Report"
```

### Good (Dynamic, Generic)

```python
def get_report_by_role(user):
    role_reports = {
        'admin': 'Admin Report',
        'manager': 'Manager Report',
        'user': 'User Report'
    }
    return role_reports.get(user.role, 'Default Report')
```

### Bad (Specific, Not Expandable)

```python
def create_user_view(request):
    # code specific to User
    pass

def create_product_view(request):
    # duplicated code for Product
    pass
```

### Good (Generic, CRUD)

```python
class GenericCreateView(LoginRequiredMixin, View):
    model = None  # Defined in subclass or via parameter
    
    def post(self, request, model_name):
        model = get_model_by_name(model_name)
        # generic creation logic
        pass
```
